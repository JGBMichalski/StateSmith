// Autogenerated with StateSmith
// Autogenerated with StateSmith
#include "Spec1Sm.h"
#include "../../lang-helpers/c/helper.h"
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
static void exit_up_to_state_handler(Spec1Sm* smSpec1Sm_Func* desired_state_exit_handler);

static void ROOT_enter(Spec1Sm* sm);

static void S_enter(Spec1Sm* sm);

static void S1_enter(Spec1Sm* sm);

static void S1_InitialState_transition(Spec1Sm* sm);

static void S11_enter(Spec1Sm* sm);

static void T1_enter(Spec1Sm* sm);

static void T11_enter(Spec1Sm* sm);

static void T111_enter(Spec1Sm* sm);


// State machine constructor. Must be called before start or dispatch event functions. Not thread safe.
void Spec1Sm_ctor(Spec1Sm* self)
{
    memset(self, 0, sizeof(*self));
}

// Starts the state machine. Must be called before dispatching events. Not thread safe.
void Spec1Sm_start(Spec1Sm* self)
{
    ROOT_enter(this);
    // ROOT behavior
    // uml: TransitionTo(ROOT.InitialState)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.InitialState`.
        // ROOT.InitialState is a pseudo state and cannot have an `enter` trigger.
        
        // ROOT.InitialState behavior
        // uml: / { trace("Transition action `` for ROOT.InitialState to S."); } TransitionTo(S)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `trace("Transition action `` for ROOT.InitialState to S.");`.
            trace("Transition action `` for ROOT.InitialState to S.");
            
            // Step 3: Enter/move towards transition target `S`.
            S_enter(this);
            
            // S.InitialState behavior
            // uml: / { trace("Transition action `` for S.InitialState to S1."); } TransitionTo(S1)
            {
                // Step 1: Exit states until we reach `S` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `trace("Transition action `` for S.InitialState to S1.");`.
                trace("Transition action `` for S.InitialState to S1.");
                
                // Step 3: Enter/move towards transition target `S1`.
                S1_enter(this);
                
                // Finish transition by calling pseudo state transition function.
                S1_InitialState_transition(this);
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for S.InitialState
        } // end of behavior for ROOT.InitialState
    } // end of behavior for ROOT
}

// Dispatches an event to the state machine. Not thread safe.
void Spec1Sm_dispatch_event(Spec1Sm* self, Spec1Sm_EventId event_id)
{
    Spec1Sm_Func behavior_func = self->current_event_handlers[event_id];
    
    while (behavior_func != NULL)
    {
        self->ancestor_event_handler = NULL;
        behavior_func(self, this);
        behavior_func = self->ancestor_event_handler;
    }
}

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
static void exit_up_to_state_handler(Spec1Sm* smSpec1Sm_Func* desired_state_exit_handler)
{
    while (sm->current_state_exit_handler != desired_state_exit_handler)
    {
        sm->current_state_exit_handler(self, sm);
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ROOT
////////////////////////////////////////////////////////////////////////////////

static void ROOT_enter(Spec1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = Spec1Sm_ROOT_exit;
    
    // ROOT behavior
    // uml: enter / { trace("Enter Spec1Sm."); }
    {
        // Step 1: execute action `trace("Enter Spec1Sm.");`
        trace("Enter Spec1Sm.");
    } // end of behavior for ROOT
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state S
////////////////////////////////////////////////////////////////////////////////

static void S_enter(Spec1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = Spec1Sm_S_exit;
    
    // S behavior
    // uml: enter / { trace("Enter S."); }
    {
        // Step 1: execute action `trace("Enter S.");`
        trace("Enter S.");
    } // end of behavior for S
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state S1
////////////////////////////////////////////////////////////////////////////////

static void S1_enter(Spec1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = Spec1Sm_S1_exit;
    
    // S1 behavior
    // uml: enter / { trace("Enter S1."); }
    {
        // Step 1: execute action `trace("Enter S1.");`
        trace("Enter S1.");
    } // end of behavior for S1
}

static void S1_InitialState_transition(Spec1Sm* sm)
{
    // S1.InitialState behavior
    // uml: / { trace("Transition action `` for S1.InitialState to S11."); } TransitionTo(S11)
    {
        // Step 1: Exit states until we reach `S1` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: `trace("Transition action `` for S1.InitialState to S11.");`.
        trace("Transition action `` for S1.InitialState to S11.");
        
        // Step 3: Enter/move towards transition target `S11`.
        S11_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        sm->state_id = Spec1Sm_StateId_S11;
        sm->ancestor_event_handler = NULL;
        return;
    } // end of behavior for S1.InitialState
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state S11
////////////////////////////////////////////////////////////////////////////////

static void S11_enter(Spec1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = Spec1Sm_S11_exit;
    sm->current_event_handlers[Spec1Sm_EventId_EV1] = Spec1Sm_S11_ev1;
    
    // S11 behavior
    // uml: enter / { trace("Enter S11."); }
    {
        // Step 1: execute action `trace("Enter S11.");`
        trace("Enter S11.");
    } // end of behavior for S11
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state T1
////////////////////////////////////////////////////////////////////////////////

static void T1_enter(Spec1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = Spec1Sm_T1_exit;
    
    // T1 behavior
    // uml: enter / { trace("Enter T1."); }
    {
        // Step 1: execute action `trace("Enter T1.");`
        trace("Enter T1.");
    } // end of behavior for T1
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state T11
////////////////////////////////////////////////////////////////////////////////

static void T11_enter(Spec1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = Spec1Sm_T11_exit;
    sm->current_event_handlers[Spec1Sm_EventId_EV2] = Spec1Sm_T11_ev2;
    
    // T11 behavior
    // uml: enter / { trace("Enter T11."); }
    {
        // Step 1: execute action `trace("Enter T11.");`
        trace("Enter T11.");
    } // end of behavior for T11
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state T111
////////////////////////////////////////////////////////////////////////////////

static void T111_enter(Spec1Sm* sm)
{
    // setup trigger/event handlers
    sm->current_state_exit_handler = Spec1Sm_T111_exit;
    
    // T111 behavior
    // uml: enter / { trace("Enter T111."); }
    {
        // Step 1: execute action `trace("Enter T111.");`
        trace("Enter T111.");
    } // end of behavior for T111
}
