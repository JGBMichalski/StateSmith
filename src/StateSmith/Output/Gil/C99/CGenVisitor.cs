using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.CSharp;
using System.Collections.Generic;
using System;
using System.Text;
using StateSmith.Common;
using System.Linq;
using StateSmith.Output.UserConfig;

#nullable enable

namespace StateSmith.Output.Gil.C99;

internal class CGenVisitor : CSharpSyntaxWalker
{
    public readonly StringBuilder hFileSb;
    public readonly StringBuilder cFileSb;
    public StringBuilder privateSb = new();
    public StringBuilder publicSb = new();
    public StringBuilder sb;
    private readonly SemanticModel model;
    private bool renderingPrototypes = false;

    public CGenVisitor(SemanticModel model, StringBuilder hFileSb, StringBuilder cFileSb, RenderConfigCVars renderConfigC, string hFileName) : base(SyntaxWalkerDepth.StructuredTrivia)
    {
        this.model = model;
        sb = hFileSb;
        this.hFileSb = hFileSb;
        this.cFileSb = cFileSb;
        hFileSb.AppendLine("// Autogenerated with StateSmith");
        hFileSb.AppendLineIfNotBlank(renderConfigC.HFileTop);
        hFileSb.AppendLine("#pragma once");
        hFileSb.AppendLine("#include <stdint.h>\n");
        hFileSb.AppendLineIfNotBlank(renderConfigC.HFileIncludes);

        cFileSb.AppendLine("// Autogenerated with StateSmith");
        cFileSb.AppendLineIfNotBlank(renderConfigC.CFileTop);
        cFileSb.AppendLine($"#include \"{hFileName}\"");
        cFileSb.AppendLineIfNotBlank(renderConfigC.CFileIncludes);
        cFileSb.AppendLine("#include <stdbool.h> // required for `consume_event` flag");
        cFileSb.AppendLine("#include <string.h> // for memset\n");
    }

    public override void VisitStructDeclaration(StructDeclarationSyntax node)
    {
        string name = GetCName(node);
        sb = hFileSb;
        sb.AppendLine($"");
        OutputStruct(node, name, outputTypedef: true);
    }

    public override void VisitClassDeclaration(ClassDeclarationSyntax node)
    {
        string name = GetCName(node);
        sb = hFileSb;

        // output enums and constants
        foreach (var kid in node.ChildNodes())
        {
            if (kid is EnumDeclarationSyntax || kid is FieldDeclarationSyntax field && IsConst(field))
                Visit(kid);
        }

        sb = hFileSb;

        // output forward declaration and comment
        sb.AppendLine($"\n");
        OutputAttachedCommentTrivia(node);
        sb.AppendLine($"// forward declaration");
        sb.AppendLine($"typedef struct {name} {name};");

        foreach (var kid in node.ChildNodes().OfType<StructDeclarationSyntax>())
        {
            Visit(kid);
        }

        foreach (var kid in node.ChildNodes().OfType<ClassDeclarationSyntax>())
        {
            Visit(kid);
        }
        
        sb = hFileSb;
        foreach (var kid in node.ChildNodes().OfType<DelegateDeclarationSyntax>())
        {
            Visit(kid);
        }
        sb.AppendLine();

        publicSb = hFileSb;
        privateSb = cFileSb;
        CaptureFunctionPrototypes(node);

        sb = hFileSb;
        OutputStruct(node, name);

        sb = cFileSb;
        publicSb = cFileSb;
        privateSb = cFileSb;

        foreach (var kid in node.ChildNodes().OfType<ConstructorDeclarationSyntax>())
        {
            Visit(kid);
        }

        foreach (var kid in node.ChildNodes().OfType<MethodDeclarationSyntax>())
        {
            Visit(kid);
        }
    }

    private void OutputStruct(TypeDeclarationSyntax node, string name, bool outputTypedef = false)
    {
        OutputAttachedCommentTrivia(node);
        if (outputTypedef)
            sb.Append("typedef ");

        sb.Append("struct ");
        OutputTokenAndTrivia(node.Identifier, name);
        OutputTokenAndTrivia(node.OpenBraceToken);
        sb.AppendLine(PostProcessor.trimBlankLinesMarker);

        foreach (var kid in node.ChildNodes())
        {
            if (kid is FieldDeclarationSyntax field && !IsConst(field))
                Visit(kid);
        }

        sb.AppendLine(PostProcessor.trimBlankLinesMarker);
        VisitLeadingTrivia(node.CloseBraceToken);
        sb.Append('}');
        if (outputTypedef)
            sb.Append($" {name}");
        sb.Append(';');
        VisitTrailingTrivia(node.CloseBraceToken);
        sb.AppendLine();
    }

    private void CaptureFunctionPrototypes(ClassDeclarationSyntax node)
    {
        renderingPrototypes = true;

        List<SyntaxNode> kids = GetMethodsAndConstructors(node);

        foreach (var kid in kids)
        {
            Visit(kid);
            sb.Append(");\n\n");
        }
        renderingPrototypes = false;
    }

    private static List<SyntaxNode> GetMethodsAndConstructors(ClassDeclarationSyntax node)
    {
        List<SyntaxNode> kids = new();
        kids.AddRange(node.ChildNodes().OfType<ConstructorDeclarationSyntax>());
        kids.AddRange(node.ChildNodes().OfType<MethodDeclarationSyntax>());
        return kids;
    }

    public override void VisitDelegateDeclaration(DelegateDeclarationSyntax node)
    {
        AppendNodeLeadingTrivia(node);
        sb.Append("typedef ");
        Visit(node.ReturnType);
        sb.Append("(*");
        var symbol = model.GetDeclaredSymbol(node).ThrowIfNull();
        sb.Append(GetCName(symbol));
        sb.Append(")(");
        sb.Append(GetCName(symbol.ContainingType) + "* self);");
        sb.Append($"{node.GetTrailingTrivia()}");
    }


    public override void VisitConstructorDeclaration(ConstructorDeclarationSyntax node)
    {
        OutputFunctionLeadingTrivia(node);

        sb.Append($"void {node.Identifier.Text}_ctor");

        Visit(node.ParameterList);

        if (!renderingPrototypes)
        {
            var body = node.Body.ThrowIfNull();
            VisitToken(body.OpenBraceToken);
            sb.Append("    memset(self, 0, sizeof(*self));\n");
            body.VisitChildrenNodesWithWalker(this);
            VisitToken(body.CloseBraceToken);
        }
    }

    private void OutputFunctionLeadingTrivia(SyntaxNode node)
    {
        if (!renderingPrototypes)
        {
            AppendNodeLeadingTrivia(node);
        }
        else
        {
            OutputAttachedCommentTrivia(node);
        }
    }

    private void OutputAttachedCommentTrivia(SyntaxNode node)
    {
        // Only output attached comments. If we find 2 or more end of line trivias without a comment trivia,
        // clear any stored trivia.
        List<SyntaxTrivia> toOutput = new();

        int endOfLineCount = 0;
        foreach (var t in node.GetLeadingTrivia())
        {
            bool isComment = t.IsKind(SyntaxKind.SingleLineCommentTrivia)
                          || t.IsKind(SyntaxKind.MultiLineCommentTrivia); // can also look at others like SingleLineDocumentationCommentTrivia

            if (t.IsKind(SyntaxKind.EndOfLineTrivia))
            {
                endOfLineCount++;
                if (endOfLineCount > 1)
                    toOutput.Clear();
                else if (toOutput.Any()) // append end of line if we already had a comment stored
                    toOutput.Add(t);
            }
            else if (isComment)
            {
                endOfLineCount = 0;
                toOutput.Add(t);
            }
        }

        foreach (var t in toOutput)
        {
            sb.Append(t);
        }
    }

    public override void VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
        sb = node.IsPublic() ? publicSb : privateSb;

        OutputFunctionLeadingTrivia(node);

        if (!node.IsPublic())
        {
            sb.Append("static ");
        }

        Visit(node.ReturnType);
        VisitToken(node.Identifier);
        Visit(node.ParameterList);

        if (!renderingPrototypes)
            Visit(node.Body);
    }

    public override void VisitBlock(BlockSyntax node)
    {
        if (renderingPrototypes)
            return;

        base.VisitBlock(node);
    }

    public override void VisitParameterList(ParameterListSyntax node)
    {
        VisitToken(node.OpenParenToken);

        ISymbol? symbol = null;

        if (node.Parent is MethodDeclarationSyntax mds)
        {
            symbol = model.GetDeclaredSymbol(mds).ThrowIfNull();
        }
        else if (node.Parent is ConstructorDeclarationSyntax cds)
        {
            symbol = model.GetDeclaredSymbol(cds).ThrowIfNull();
        }

        if (symbol?.IsStatic == false)
        {
            sb.Append(GetCName(symbol.ContainingType) + "* self");
            if (node.Parameters.Count > 0)
            {
                sb.Append(", ");
            }
        }

        foreach (var p in node.Parameters)
        {
            Visit(p);
        }

        if (!renderingPrototypes)
            VisitToken(node.CloseParenToken);
    }

    public override void VisitArgumentList(ArgumentListSyntax node)
    {
        var invocation = (InvocationExpressionSyntax)node.Parent.ThrowIfNull();

        var iMethodSymbol = (IMethodSymbol)model.GetSymbolInfo(invocation).ThrowIfNull().Symbol.ThrowIfNull();

        VisitToken(node.OpenParenToken);

        if (iMethodSymbol.IsStatic == false)
        {
            sb.Append("self");
            if (node.Arguments.Count > 0)
            {
                sb.Append(", ");
            }
        }

        foreach (var p in node.Arguments)
        {
            Visit(p);
        }

        VisitToken(node.CloseParenToken);
    }

    public override void VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
    {
        bool done = false;

        if (ExpressionIsEnumMember(node.Expression))
        {
            // used for enum access: `MyEnumClass.EnumName`
            Visit(node.Name);
            done = true;
        }
        else
        {
            bool isPtr = false;

            if (node.IsKind(SyntaxKind.SimpleMemberAccessExpression))
            {
                if (node.Expression is ThisExpressionSyntax tes)
                {
                    VisitLeadingTrivia(tes.Token);
                    sb.Append("self");
                    VisitTrailingTrivia(tes.Token);
                    isPtr = true;
                }
                else
                {
                    Visit(node.Expression);
                }

                if (isPtr)
                {
                    sb.Append("->");
                    VisitTrailingTrivia(node.OperatorToken);
                }
                else
                {
                    VisitToken(node.OperatorToken);
                }

                Visit(node.Name);
                done = true;

                //if (node.Expression is IdentifierNameSyntax ins)
                //{
                //    ISymbol? symbol = model.GetSymbolInfo(ins).Symbol;

                //    if (symbol is IFieldSymbol fieldSymbol)
                //    {
                //        if (!fieldSymbol.IsStatic && !fieldSymbol.IsConst)
                //        {
                //            sb.Append("self->");
                //            done = false; // let it continue
                //        }
                //    }
                //}
            }
        }

        if (!done)
            base.VisitMemberAccessExpression(node);
    }

    public override void VisitNullableType(NullableTypeSyntax node)
    {
        // converts `Func? behavior_func` to `Func behavior_func`
        Visit(node.ElementType);
        VisitLeadingTrivia(node.QuestionToken);
        VisitTrailingTrivia(node.QuestionToken);
    }

    private bool ExpressionIsEnumMember(ExpressionSyntax expressionSyntax)
    {
        ISymbol? symbol = model.GetSymbolInfo(expressionSyntax).Symbol;

        if (symbol == null)
            return false;

        if (symbol is IParameterSymbol ps && ps.Type.TypeKind == TypeKind.Enum)
        {
            return true;
        }

        if (symbol is IFieldSymbol f && f.Type.TypeKind == TypeKind.Enum)
        {
            return true;
        }

        if (symbol is INamedTypeSymbol nts && nts.TypeKind == TypeKind.Enum)
        {
            return true;
        }

        return false;
    }

    public override void VisitToken(SyntaxToken token)
    {
        token.LeadingTrivia.VisitWith(this);

        switch ((SyntaxKind)token.RawKind)
        {
            case SyntaxKind.PublicKeyword:
            case SyntaxKind.EnumKeyword:
            case SyntaxKind.StaticKeyword:
            case SyntaxKind.ReadOnlyKeyword:
            case SyntaxKind.PrivateKeyword:
                return;
        }

        if (token.IsKind(SyntaxKind.ExclamationToken) && token.Parent.IsKind(SyntaxKind.SuppressNullableWarningExpression))
        {
            // ignore exclamations like: `this.current_state_exit_handler!();`
        }
        else if (token.IsKind(SyntaxKind.IdentifierToken) && token.Parent is MethodDeclarationSyntax mds)
        {
            sb.Append(GetCName(model.GetDeclaredSymbol(mds).ThrowIfNull()));
        }
        else if (token.IsKind(SyntaxKind.IdentifierToken) && token.Parent is EnumMemberDeclarationSyntax emds)
        {
            sb.Append(GetCName(model.GetDeclaredSymbol(emds).ThrowIfNull()));
        }
        else
        {
            sb.Append(token);
        }

        token.TrailingTrivia.VisitWith(this);
    }

    public override void VisitTrivia(SyntaxTrivia trivia)
    {
        sb.Append(trivia);
    }

    public override void VisitBinaryExpression(BinaryExpressionSyntax node)
    {
        bool done = false;

        if (node.IsKind(SyntaxKind.EqualsExpression) && node.Left is LiteralExpressionSyntax left)
        {
            if (left.Token.ToString() == "383849285762")
            {
                done = true;
                VisitTrailingTrivia(node.GetLastToken());
            }
        }

        if (!done)
            base.VisitBinaryExpression(node);
    }

    public override void VisitCastExpression(CastExpressionSyntax node)
    {
        if (IsEnumMemberConversionToInt(node))
        {
            // just visit expression so we omit int cast
            // `(int32_t)event_id` ---> `event_id`
            Visit(node.Expression);
        }
        else
        {
            base.VisitCastExpression(node);
        }
    }

    private bool IsEnumMemberConversionToInt(CastExpressionSyntax node)
    {
        if (node.Type is PredefinedTypeSyntax pts && pts.Keyword.IsKind(SyntaxKind.IntKeyword))
        {
            if (ExpressionIsEnumMember(node.Expression))
            {
                return true;
            }
        }

        return false;
    }

    public override void VisitIdentifierName(IdentifierNameSyntax node)
    {
        var result = node.Identifier.Text;

        switch (result)
        {
            case "Boolean": result = "bool"; break;
            case "SByte": result = "int8_t"; break;
            case "Byte": result = "uint8_t"; break;
            case "Int16": result = "int16_t"; break;
            case "UInt16": result = "uint16_t"; break;
            case "Int32": result = "int32_t"; break;
            case "UInt32": result = "uint32_t"; break;
            case "Int64": result = "int64_t"; break;
            case "UInt64": result = "uint64_t"; break;
            case "Double": result = "float"; break;
            case "Single": result = "double"; break;

            default:
                {
                    SymbolInfo symbol = model.GetSymbolInfo(node);
                    result = GetCName(symbol.Symbol.ThrowIfNull());
                    break;
                }
        }

        node.VisitLeadingTriviaWith(this);
        sb.Append(result);
        node.VisitTrailingTriviaWith(this);
    }

    public override void VisitPredefinedType(PredefinedTypeSyntax node)
    {
        string result = node.Keyword.Text switch
        {
            "void" => "void",
            "bool" => "bool",
            "sbyte" => "int8_t",
            "byte" => "uint8_t",
            "short" => "int16_t",
            "ushort" => "uint16_t",
            "int" => "int32_t",
            "uint" => "uint32_t",
            "long" => "int64_t",
            "ulong" => "uint64_t",
            "float" => "float",
            "double" => "double",
            _ => throw new NotImplementedException(node + ""),
        };

        node.VisitLeadingTriviaWith(this);
        sb.Append(result);
        node.VisitTrailingTriviaWith(this);
    }

    public override void VisitLiteralExpression(LiteralExpressionSyntax node)
    {
        if (node.IsKind(SyntaxKind.NullLiteralExpression))
        {
            sb.Append("NULL");
        }
        else
        {
            base.VisitLiteralExpression(node);
        }
    }

    private static bool IsConst(FieldDeclarationSyntax? node)
    {
        if (node == null) return false;

        return node.Modifiers.Any(d => (SyntaxKind)d.RawKind == SyntaxKind.ConstKeyword);
    }

    public override void VisitVariableDeclaration(VariableDeclarationSyntax node)
    {
        if (node.Type is ArrayTypeSyntax)
        {
            HandleArrayVarDecl(node);
        }
        else
        {
            base.VisitVariableDeclaration(node);
        }
    }

    public override void VisitFieldDeclaration(FieldDeclarationSyntax node)
    {
        bool done = false;
        bool useDefine = false;
        bool useEnum = true;

        if (IsConst(node))
        {
            if (useDefine)
            {
                done = true;
                AppendNodeLeadingTrivia(node);
                sb.Append("#define ");
                var decl = node.Declaration.Variables.Single();
                sb.Append(GetCName(model.GetDeclaredSymbol(decl).ThrowIfNull()));
                sb.Append(' ');
                Visit(decl.Initializer.ThrowIfNull().Value);
                sb.Append('\n');
            }
            else if (useEnum)
            {
                done = true;
                AppendNodeLeadingTrivia(node);
                sb.Append("enum\n{\n    ");
                Visit(node.Declaration.Variables.Single());
                sb.Append("\n};\n");
            }
        }


        if (!done)
        {
            base.VisitFieldDeclaration(node);
        }
    }

    public override void VisitVariableDeclarator(VariableDeclaratorSyntax node)
    {
        if (IsConst(node.FirstAncestorOrSelf<FieldDeclarationSyntax>()))
        {
            sb.Append(GetCName(model.GetDeclaredSymbol(node).ThrowIfNull()));
            VisitTrailingTrivia(node.Identifier);
        }
        else
        {
            VisitToken(node.Identifier);
        }

        if (node.Initializer?.Value is ObjectCreationExpressionSyntax)
        {
            sb.Append(PostProcessor.trimHorizontalWhiteSpaceMarker);
        }
        else
        {
            Visit(node.Initializer);
        }
    }

    private void HandleArrayVarDecl(VariableDeclarationSyntax node)
    {
        var ats = (ArrayTypeSyntax)node.Type;
        Visit(ats.ElementType);
        sb.Append(' ');

        foreach (VariableDeclaratorSyntax v in node.Variables)
        {
            sb.Append(v.Identifier);

            var rank = v.DescendantNodes().OfType<ArrayRankSpecifierSyntax>().SingleOrDefault();
            if (rank != null)
                Visit(rank);
        }
    }

    public override void VisitEnumDeclaration(EnumDeclarationSyntax node)
    {
        AppendNodeLeadingTrivia(node);
        string name = GetCName(node);
        OutputTokenAndTrivia(node.Identifier, "typedef enum " + name);
        OutputTokenAndTrivia(node.OpenBraceToken);

        foreach (var kid in node.ChildNodesAndTokens().SkipWhile(n => n.IsToken))
        {
            if (kid.IsNode)
            {
                Visit(kid.AsNode());
            }
            else
            {
                if (kid == node.CloseBraceToken)
                    break;
                VisitToken(kid.AsToken());
            }
        }

        VisitLeadingTrivia(node.CloseBraceToken);
        sb.Append($"}} {name};");
        VisitTrailingTrivia(node.CloseBraceToken);
    }

    private void OutputTokenAndTrivia(SyntaxToken token, string? tokenValue = null)
    {
        sb.Append(token.LeadingTrivia);
        sb.Append(tokenValue ?? token.ToString());
        sb.Append(token.TrailingTrivia);
    }

    private void AppendNodeLeadingTrivia(SyntaxNode node)
    {
        sb.Append($"{node.GetLeadingTrivia()}");
    }

    private static string GetFQN(ISymbol symbol)
    {
        var parts = new List<string>();

        parts.Insert(index: 0, symbol.Name);
        symbol = symbol.ContainingSymbol;

        while (symbol != null)
        {
            if (symbol is INamespaceSymbol namespaceSymbol)
            {
                // need to stop at global namespace to prevent ascending into dll
                if (namespaceSymbol.IsGlobalNamespace)
                {
                    break;
                }
            }

            if (symbol is not IMethodSymbol)
                parts.Insert(index: 0, symbol.Name);

            symbol = symbol.ContainingSymbol;
        }

        var fqn = string.Join(".", parts);
        return fqn;
    }

    private static string MangleTypeSymbolName(string fullyQualifiedName)
    {
        string textName = fullyQualifiedName.Replace(oldChar: '.', newChar: '_');
        return textName;
    }



    private string GetCName(ClassDeclarationSyntax node)
    {
        INamedTypeSymbol symbol = model.GetDeclaredSymbol(node).ThrowIfNull();
        return GetCName(symbol);
    }

    private string GetCName(StructDeclarationSyntax node)
    {
        INamedTypeSymbol symbol = model.GetDeclaredSymbol(node).ThrowIfNull();
        return GetCName(symbol);
    }

    private string GetCName(EnumDeclarationSyntax node)
    {
        INamedTypeSymbol symbol = model.GetDeclaredSymbol(node).ThrowIfNull();
        return GetCName(symbol);
    }

    private static string GetCName(ISymbol symbol)
    {
        if (symbol is IFieldSymbol fieldSymbol)
        {
            if (!fieldSymbol.IsStatic && !fieldSymbol.IsConst)
            {
                return fieldSymbol.Name;
            }
        }

        if (symbol.Kind == SymbolKind.Parameter || symbol.Kind == SymbolKind.Local)
        {
            return symbol.Name;
        }

        if (symbol is IMethodSymbol methodSymbol && methodSymbol.DeclaredAccessibility != Accessibility.Public)
        {
            return methodSymbol.Name;
        }

        var fqn = GetFQN(symbol);
        var name = MangleTypeSymbolName(fqn);
        return name;
    }

    private static string GetCName(SymbolInfo symbolInfo)
    {
        return GetCName(symbolInfo.Symbol.ThrowIfNull());
    }
}
